/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "app_fatfs.h"
#include "i2c.h"
#include "usart.h"
#include "spi.h"
#include "tim.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "sd_functions.h"
#include "sd_benchmark.h"
#include "dataBuffer.h"

#include "string.h"
#include "stdio.h"
#include "MPU6050.h"
#include "math.h"
#include "mpu_madgwick.h"

//gps
#include "gps.h"

//obd2
#include "elm327.h"

//sd

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */


//UART_HandleTypeDef hlpuart1;

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
//idle
char idleMode = 0;
//miniSD CARD
uint8_t bufr[80];
UINT br;
char sdWriteBuffer[8192];
char sdPhraseBuffer[128];

SDCyclic_t SDLogger;
char sdLineBuffer[128];
char ready2SaveFlag =0;

//Accelerometer
float Ax, Ay, Az;
float Gx, Gy, Gz;
float relAx, relAy, relAz;
float accLinX, accLinY, accLinZ;
unsigned int uiMsCounter = 0;
float mean_pitch, mean_roll, mean_yaw, mean_ax, mean_ay, mean_az = 0;

//bt
uint8_t rxBt;

//gps
GPS_t GPS;

//obd2
uint8_t uart_rx_byte;
uint8_t uart_rx_buffer[UART_RX_BUFFER_SIZE];
uint8_t rxLPUART;

float velocity = 0;
float motorRPM = 0;
float fuelConsumption = 0;
int throttle = 0 ;
int gear = 1;

SensorData_t data;
DataBuffer_t dataBuffer;


#define MPU6050_ADDR 0xD0   // endereço I2C (AD0 = GND → 0x68)
#define MPU6050_ACCEL_XOUT_H 0x3B


/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

int _write(int fd, unsigned char *buf, int len) {
  if (fd == 1 || fd == 2) {                     // stdout or stderr ?
    HAL_UART_Transmit(&hlpuart1, buf, len, 999);  // Print to the UART
  }
  return len;
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_LPUART1_UART_Init();
  MX_SPI2_Init();
  MX_I2C1_Init();
  MX_TIM6_Init();
  MX_USART3_UART_Init();
  MX_USART1_UART_Init();
  MX_UART4_Init();
  /* USER CODE BEGIN 2 */
  GPS_Init();
  //logger
  SDCyclicInit(&SDLogger);


  //test MiniSD card
    //sd_mount();
//  sd_append_file("File10.txt", "NEW DATA FROM AUTOLOGGER\n\r");
//  sd_read_file("File10.txt", bufr, 80, &br);
//  printf("DATA from File:::: %s\n\n",bufr);
   //sd_unmount();
  //sd_benchmark();


  // Accelerometer initialization
  HAL_StatusTypeDef ret = HAL_I2C_IsDeviceReady(&hi2c1, 0b1101000 <<1 + 0 , 1, 100);

  MPU6050_init();

  if (ret == HAL_OK){
	  printf("The Device is Ready\n\r");
  } else {
	  printf("Device not ready \n");
  }
  // Calibração do giroscópio com sensor parado
  printf("Calibrating gyro... keep IMU still\n\r");
  //CalibrateGyro(200); // 200 amostras
  printf("Gyro bias: %.3f %.3f %.3f (deg/s)\n\r", gyroBiasX, gyroBiasY, gyroBiasZ);
  HAL_UART_Receive_IT(&huart1, &uart_rx_byte, 1);
  HAL_UART_Receive_IT(&huart4, &rxBt, 1);
  //ELM327InitDebug(&huart1);

  //uint32_t last = HAL_GetTick();
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
  HAL_TIM_Base_Start_IT(&htim6);
  HAL_UART_Receive_IT(&hlpuart1, &rxLPUART, 1);
  HAL_NVIC_EnableIRQ(USART3_IRQn);
  HAL_NVIC_EnableIRQ(USART1_IRQn);
  HAL_NVIC_EnableIRQ(LPUART1_IRQn);

  static SensorData_t dataSnapshot;
  static char line[160];
  while (1)
  {
	  if(!idleMode){
		  //copia o data para eviat problemas de inserção e remoção comcomitante
		  __disable_irq();
		  if(dataBufferPop(&dataBuffer, &dataSnapshot)){
			  __enable_irq();
			  sprintf(line,
					  "%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.6f,%.6f,%.1f,%.0f,%.2f,%d,%d\r\n",
					  dataSnapshot.pitch_deg, dataSnapshot.roll_deg, dataSnapshot.yaw_deg,
					  dataSnapshot.linAx_ms2, dataSnapshot.linAy_ms2, dataSnapshot.linAz_ms2,
					  dataSnapshot.latitude, dataSnapshot.longitude,
					  dataSnapshot.velocity, dataSnapshot.motorRPM,
					  dataSnapshot.fuelConsumption, dataSnapshot.throttle, dataSnapshot.gear);

			  printf("%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.6f,%.6f,%.1f,%.0f,%.2f,%d,%d\r\n",
							  dataSnapshot.pitch_deg, dataSnapshot.roll_deg, dataSnapshot.yaw_deg,
							  dataSnapshot.linAx_ms2, dataSnapshot.linAy_ms2, dataSnapshot.linAz_ms2,
							  dataSnapshot.latitude, dataSnapshot.longitude,
							  dataSnapshot.velocity, dataSnapshot.motorRPM,
							  dataSnapshot.fuelConsumption, dataSnapshot.throttle, dataSnapshot.gear);
			  SDCyclicAddLine(&SDLogger, line);
			  if(SDLogger.lineCount >= SAFE_MAX_DATA_BUFFER_SIZE )
							ready2SaveFlag = 1;

		  }
		  else
			  __enable_irq();

			if(ready2SaveFlag){
//				__disable_irq();
				SDCyclicFlush(&SDLogger, "log.csv");
//				__enable_irq();
				ready2SaveFlag = 0;
			}
			HAL_Delay(50);

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  }
  else
  {
	  printf("Idle Mode On \n\r");
	  HAL_Delay(1000);
	  if(SDLogger.mounted)
		  sd_unmount(&SDLogger);
  }
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){
	if(htim->Instance==TIM6)
	{
		if(!idleMode){
			uiMsCounter+=1;

			if(!(uiMsCounter%10)){
	//			IMU_Update(0.01);
	//			MPU6050AddSample(pitch_deg, roll_deg, yaw_deg, linAx_ms2, linAy_ms2, linAz_ms2);
			}

			if(!(uiMsCounter%100)){
				IMU_Update(0.1);

				data.pitch_deg = pitch_deg;
				data.roll_deg  = roll_deg;
				data.yaw_deg   = yaw_deg;

				data.linAx_ms2 = linAx_ms2;
				data.linAy_ms2 = linAy_ms2;
				data.linAz_ms2 = linAz_ms2;

				// --- Atualiza GPS ---
				data.latitude  = GPS.dec_latitude;
				data.longitude = GPS.dec_longitude;

				// --- Atualiza OBD2 ---
				data.velocity        = velocity;
				data.motorRPM        = motorRPM;
				data.fuelConsumption = fuelConsumption;
				data.throttle        = throttle;
				data.gear            = gear;

				//ELM327SendCommand("010C");
	//			printf("Pitch=%.2f Roll=%.2f Yaw=%.2f | a_lin: X=%.2f Y=%.2f Z=%.2f (m/s2)\r\n",
	//			       pitch_deg, roll_deg, yaw_deg,
	//			       linAx_ms2, linAy_ms2, linAz_ms2);
	//			printf("Lat= %.2f Lon= %.2f\r\n", GPS.dec_latitude, GPS.dec_longitude);
	//			printf("Velocidade: %.1f km/h | RPM: %.0f | Consumo: %.2f L/h | Acelerador: %d%% | Marcha: %d\r\n",
	//			       velocity, motorRPM, fuelConsumption, throttle, gear);

				dataBufferPush(&dataBuffer, &data);

			}
			//if(!(uiMsCounter%1000)){

			//}
		}
		else
		{

		}
	}
//            sprintf(sdLineBuffer,
//                    "%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.6f,%.6f,%.1f,%.0f,%.2f,%d,%d\r\n",
//                    pitch_deg, roll_deg, yaw_deg,
//                    linAx_ms2, linAy_ms2, linAz_ms2,
//                    GPS.dec_latitude, GPS.dec_longitude,
//					  velocity, motorRPM, fuelConsumption, throttle, gear);


//
//            SDCyclic_AddLine(&SDLogger, sdLineBuffer);

//            printf("%s", sdLineBuffer);
//			MPU6050ComputeMean(&mean_pitch, &mean_roll, &mean_yaw, &mean_ax, &mean_ay, &mean_az);
//			printf("MÉDIA (último 1s): "
//			           "Pitch=%.2f Roll=%.2f Yaw=%.2f | a_lin: X=%.2f Y=%.2f Z=%.2f (m/s²)\r\n",
//			           mean_pitch, mean_roll, mean_yaw, mean_ax, mean_ay, mean_az);




}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	if(!idleMode){
	  if (huart == &huart3) {
		GPS_UART_CallBack();
	  }
	  if(huart->Instance == USART1){
		//ELM327UARTCallback();
		//HAL_UART_Receive_IT(&huart1, &uart_rx_byte, 1);
		//HAL_UART_Transmit_IT(&hlpuart1, &uart_rx_byte, 1);
	  }
	}

  if (huart == &hlpuart1)
  {
	  // Para recepção do PC, apenas retransmite imediatamente para USART1
	  //HAL_UART_Transmit(&huart1, &rxLPUART, 1, HAL_MAX_DELAY);

	  // Reinicia a recepção
	  HAL_UART_Receive_IT(&hlpuart1, &rxLPUART, 1);
  }
  if (huart == &huart4)
  {
	  printf("get bt");
	  // Reinicia a recepção
	  HAL_UART_Transmit_IT(&hlpuart1, &rxBt, 1);
	  HAL_UART_Receive_IT(&huart4, &rxBt, 1);
  }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
	if (GPIO_Pin == B1_Pin){
		idleMode = 1;
	}

}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
